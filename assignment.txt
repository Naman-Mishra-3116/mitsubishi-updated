q1: 

code: 

import { randomUUID } from "crypto";
import { Request } from "express";
import multer, { diskStorage, FileFilterCallback } from "multer";
import path from "path";

export const IMAGE_STORAGE_PATH = path.join(
  __dirname,
  "../../../uploads/images"
);
export const XLSX_STORAGE_PATH = path.join(
  __dirname,
  "../../../uploads/trainings"
);

const fileFilter = (
  _req: Request,
  file: Express.Multer.File,
  cb: FileFilterCallback
) => {
  if (
    [
      "image/jpeg",
      "image/png",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ].includes(file.mimetype)
  ) {
    cb(null, true);
  } else {
    console.log("invalid mime type: ", file.mimetype);
    cb(null, false);
  }
};

const storage = diskStorage({
  destination: (_req, file, cb) => {
    if (file.mimetype.startsWith("image/")) {
      cb(null, IMAGE_STORAGE_PATH);
    } else {
      cb(null, XLSX_STORAGE_PATH);
    }
  },
  filename: (_req, file, cb) => {
    const uniqueId = randomUUID() + "-" + Date.now();
    const ext = path.extname(file.originalname);
    cb(null, `${file.fieldname}-${uniqueId}${ext}`);
  },
});

export const UploadFile = multer({
  storage,
  fileFilter,
  limits: { fileSize: 1024 * 1024 * 10 },
});


-----------------------------------------------

q2: 

import { Router } from "express";
import validateJWTToken from "../../../middleware/validateToken.middleware";
import controllers from "../../../controllers";
import { UploadFile } from "../../../middleware/multer.middleware";

const mountATCRouter = (router: Router) => {
  router.post(
    "/createATC",
    validateJWTToken,
    UploadFile.single("atcImage"),
    controllers.atcControllers.createATC
  );
  router.get("/allATC", validateJWTToken, controllers.atcControllers.getAllATC);

  router.post(
    "/updateStatus/:id",
    validateJWTToken,
    controllers.atcControllers.changeStatus
  );

  router.post(
    "/updateStatus/:id",
    validateJWTToken,
    controllers.atcControllers.changeStatus
  );

  router.post(
    "/edit/:id",
    validateJWTToken,
    UploadFile.single("atcImage"),
    controllers.atcControllers.editATCById
  );

  router.get("/:id", validateJWTToken, controllers.atcControllers.getATCById);

  router.post(
    "/createTraining",
    validateJWTToken,
    UploadFile.fields([
      { name: "trainingImages", maxCount: 5 },
      { name: "attendence", maxCount: 1 },
    ]),
    controllers.atcControllers.createTraining
  );
};
export default mountATCRouter;

import { NextFunction, Request, Response } from "express";
import { getFilePaths } from "../../../utils/getFilePaths";
import { Training } from "../../../models/training.model";
import { ErrorResponse, ErrorType } from "../../../utils/customError";
import { jsonResponse } from "../../../utils/jsonResponse";

export const createTraining = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  let trainingImagePaths: string[] = [];
  let attendencePath: string | undefined;
  const files = req.files as IFiles;
  const { startDate, endDate, totalStudents, title, description } = req.body;
  const { atcId } = res.locals.userData;

  if (files?.["trainingImages"]) {
    trainingImagePaths = files["trainingImages"].map(
      (file: Express.Multer.File) => getFilePaths(req, "images", file.filename)
    ) as string[];
  }

  if (files["attendence"] && files["attendence"].length > 0) {
    attendencePath = getFilePaths(
      req,
      "trainings",
      files["attendence"][0].filename
    );
  }

  const existingTraining = await Training.findOne({
    atcId,
    title,
    startDate: { $lte: endDate },
    endDate: { $gte: startDate },
  });

  if (existingTraining) {
    return next(
      new ErrorResponse(
        ErrorType.BAD_REQUEST,
        "This training has already been added to the database for your ATC in the given date range",
        "This training has already been added to the database for your ATC in the given date range"
      )
    );
  }

  const newTraining = await Training.create({
    atcId,
    startDate,
    endDate,
    title,
    description,
    totalStudents,
    trainingImages: trainingImagePaths,
    attendence: attendencePath,
    isApproved: false,
  });

  return jsonResponse(res, {
    status: "success",
    statusCode: 200,
    title: "Training Created Successfully!",
    message: "Training Record Added successfully!",
    data: newTraining._id,
  });
};




-------------------------------------------------

q3: 

"use client";
import { Box } from "@mantine/core";
import React, { memo } from "react";
import classes from "../styles/dashboardContainer.module.scss";
import DashboardCard from "./DashboardCard";
import { ICONS } from "@/assets/icons";
import { useGetDashboardData } from "@/hooks/query/useGetDashboardStats.query";

const DashBoardContainer: React.FC = () => {
  const { data } = useGetDashboardData();
  return (
    <Box className={classes.root}>
      <DashboardCard
        Icon={ICONS.adminIcon}
        name="Admins"
        figure={data?.data?.totalAdmins ?? 0}
        lastUpdated="today"
      />
      <DashboardCard
        Icon={ICONS.atcIcon}
        name="Training Centers"
        figure={data?.data?.totalATCs ?? 0}
        lastUpdated="today"
      />
      <DashboardCard
        Icon={ICONS.trainingIcon}
        name="Trainings"
        figure={data?.data?.totalTrainings ?? 0}
        lastUpdated="today"
      />
      <DashboardCard
        lastUpdated="today"
        Icon={ICONS.studentIcon}
        name="Students trained"
        figure={data?.data?.totalStudents ?? 0}
      />
    </Box>
  );
};

export default memo(DashBoardContainer);

-----------------------------------------------------

q4:

"use client";
import MButton from "@/ui/MButton/MButton";
import openImageCropperModal from "@/ui/MImageCropper/fragments/openCropperModal";
import MInput from "@/ui/MInput/MInput";
import MTypography from "@/ui/MTypography/MTypography";
import { ActionIcon, Box, Group, Text } from "@mantine/core";
import { DatePickerInput } from "@mantine/dates";
import "@mantine/dates/styles.css";
import { Dropzone, IMAGE_MIME_TYPE } from "@mantine/dropzone";
import "@mantine/dropzone/styles.css";
import { useForm, yupResolver } from "@mantine/form";
import { IconCrop, IconPhoto, IconUpload, IconX } from "@tabler/icons-react";
import Image from "next/image";
import React, { memo } from "react";
import classes from "../styles/index.module.scss";
import {
  createTrainingInitails,
  trainingFormSchema,
  validateExcelColumns,
} from "@/validation/createTrainingValidator";
import { notifications } from "@mantine/notifications";
import { useCreateTrainingMutation } from "@/hooks/mutation/useCreateTrainingMutation.mutation";

type FormValues = {
  title: string;
  description: string;
  startDate: string;
  endDate: string;
  attendence: File | null;
  totalStudents: number;
  trainingImages: File[];
};

const CreateTrainingForm: React.FC = () => {
  const form = useForm<FormValues>({
    initialValues: createTrainingInitails,
    validate: yupResolver(trainingFormSchema),
  });

  const { mutateAsync } = useCreateTrainingMutation();
  const handleSubmit = async (values: typeof form.values) => {
    const isExcelValid = await validateExcelColumns(values.attendence);
    if (!isExcelValid) {
      form.setFieldError(
        "attendence",
        "The Excel file should contain Name, RollNumber, Email, TotalAttendance, Feedback"
      );
      notifications.show({
        title: "Invalid Structure for attendence file",
        color: "blue",
        message:
          "The Excel file should contain Name, RollNumber, Email, TotalAttendance,Feedback",
      });
      return;
    }
    console.log(values.attendence);
    const fd = new FormData();
    fd.append("attendence", values.attendence as File);
    fd.append("startDate", values.startDate);
    fd.append("endDate", values.endDate);
    fd.append("title", values.title);
    fd.append("description", values.description);
    fd.append("totalStudents", values.totalStudents.toString());
    if (values.trainingImages) {
      values.trainingImages.forEach((item) => {
        fd.append("trainingImages", item);
      });
    }

    const resp = await mutateAsync(fd);
    notifications.show({
      message: resp.message,
      color: resp.status === "success" ? "green" : "red",
    });
  };

  const handleDrop = (files: File[]) => {
    const newFiles = files.slice(0, 5 - form.values.trainingImages.length);
    form.setFieldValue("trainingImages", [
      ...form.values.trainingImages,
      ...newFiles,
    ]);
  };

  const removeFile = (index: number) => {
    const updated = [...form.values.trainingImages];
    updated.splice(index, 1);
    form.setFieldValue("trainingImages", updated);
  };
  return (
    <Box className={classes.rootBox}>
      <Box className={classes.header}>
        <MTypography
          variant="heading"
          color="white"
          text="Create Training"
          className={classes.heading}
        />
        <MTypography
          className={classes.subHeading}
          variant="subTitle"
          text="fill all the details about the training"
          color="white"
        />
      </Box>

      <form className={classes.form} onSubmit={form.onSubmit(handleSubmit)}>
        <MInput
          required
          variant="text"
          label="Training title"
          className={classes.fullGrid}
          placeholder="Example title"
          formHandler={form.getInputProps("title")}
        />

        <MInput
          required
          variant="textarea"
          label="Training Description"
          placeholder="Example Training description"
          formHandler={form.getInputProps("description")}
          className={classes.fullGrid}
        />

        <Box
          style={{
            display: "grid",
            gridTemplateColumns: "1fr 1fr 1fr",
            gap: "20px",
          }}
          className={classes.fullGrid}
        >
          <DatePickerInput
            withAsterisk
            {...form.getInputProps("startDate")}
            label="Start Date"
            placeholder="6th November 2024"
            classNames={{
              input: classes.input,
            }}
          />

          <DatePickerInput
            {...form.getInputProps("endDate")}
            withAsterisk
            label="End Date"
            placeholder="7th October 2024"
            classNames={{
              input: classes.input,
            }}
          />

          <MInput
            required
            variant="text"
            label="Total Students"
            placeholder="55"
            formHandler={form.getInputProps("totalStudents")}
          />
        </Box>
        <MInput
          placeholder="XlSX file containing attendence"
          accept="xlsx"
          required
          variant="file"
          className={classes.fullGrid}
          label="Attendance File"
          formHandler={form.getInputProps("attendence")}
        />
        <Box style={{ display: "flex", flexDirection: "column", gap: "10px" }}>
          <Text mt={"10px"} size="14px">
            Training Images <span style={{ color: "red" }}>*</span>
          </Text>
          <Text mt={"-10px"} c={"red"} size="12px">
            {form.errors.trainingImages}
          </Text>
        </Box>

        {form.values.trainingImages.length < 5 && (
          <Dropzone
            mt={"-10"}
            onDrop={handleDrop}
            onReject={(files) => console.log("rejected", files)}
            maxSize={5 * 1024 ** 2}
            accept={IMAGE_MIME_TYPE}
            className={classes.fullGrid}
          >
            <Group
              justify="center"
              gap="xl"
              mih={220}
              style={{ pointerEvents: "none" }}
            >
              <Dropzone.Accept>
                <IconUpload
                  size={52}
                  color="var(--mantine-color-blue-6)"
                  stroke={1.5}
                />
              </Dropzone.Accept>
              <Dropzone.Reject>
                <IconX
                  size={52}
                  color="var(--mantine-color-red-6)"
                  stroke={1.5}
                />
              </Dropzone.Reject>
              <Dropzone.Idle>
                <IconPhoto
                  size={52}
                  color="var(--mantine-color-dimmed)"
                  stroke={1.5}
                />
              </Dropzone.Idle>

              <div>
                <Text size="xl" inline>
                  Drag images here or click to select files
                </Text>
                <Text size="sm" c="dimmed" inline mt={7}>
                  Maximum 5 images, each under 5MB.
                </Text>
              </div>
            </Group>
          </Dropzone>
        )}
        <Group mt="md" wrap="wrap" className={classes.fullGrid}>
          {form.values.trainingImages.map((file, index) => (
            <Box
              key={index}
              style={{
                border: "1px solid #ddd",
                borderRadius: "8px",
                padding: "10px",
                width: "130px",
                textAlign: "center",
              }}
            >
              <Image
                src={URL.createObjectURL(file)}
                alt={file.name}
                height={100}
                width={100}
              />
              <Box
                style={{
                  display: "flex",
                  justifyContent: "space-between",
                  gap: "8px",
                  width: "100%",
                }}
              >
                <ActionIcon
                  w={"50%"}
                  variant="light"
                  color="red"
                  onClick={() => removeFile(index)}
                >
                  <IconX size={14} />
                </ActionIcon>
                <ActionIcon
                  w={"50%"}
                  variant="light"
                  color="blue"
                  onClick={() =>
                    openImageCropperModal(
                      form.values.trainingImages[index],
                      (croppedImage) => {
                        if (!croppedImage) return;
                        const updated = [...form.values.trainingImages];
                        updated[index] = croppedImage as File;
                        form.setFieldValue("trainingImages", updated);
                      },
                      "rect",
                      16 / 9
                    )
                  }
                >
                  <IconCrop size={14} />
                </ActionIcon>
              </Box>
            </Box>
          ))}
        </Group>

        <MButton type="submit" text="Update" radius="md" variant="filled" />
      </form>
    </Box>
  );
};

export default memo(CreateTrainingForm);



--------------------------------------------

q5:

import { API_URL } from "@/enums/apiUrls.enum";
import { QUERY_KEY } from "@/enums/queryKey.enum";
import { request } from "@/services/axios.service";
import { useQuery } from "@tanstack/react-query";

const fetchData = async (data: PaginationProps) => {
  const resp = await request({
    url: API_URL.GET_ALL_TRAINING,
    method: "GET",
    data,
  });

  return resp;
};

export const useGetATCTrainings = (data: PaginationProps) => {
  return useQuery({
    queryFn: () => fetchData(data),
    queryKey: [QUERY_KEY.TRAINING_DATA],
  });
};


import { Request } from "express";

export const getFilePaths = (
  req: Request,
  directory: "images" | "trainings",
  fileName: string | undefined
) => {
  if (fileName) {
    return `${req.protocol}://${req.get(
      "host"
    )}/uploads/${directory}/${fileName}`;
  }

  return undefined;
};
